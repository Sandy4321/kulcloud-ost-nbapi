#  
#  Copyright (C) 2013, Seok Hwan Kong <seokhwan.kong@kulcloud.net>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#

from kulcloud.core import mlapi_base_v1
from kulcloud.core.v1.mul_nbapi import ofp_switch_features
from kulcloud.core.v1.mul_nbapi import nbapi_switch_brief_list_t
from kulcloud.core.v1.mul_nbapi import ofp_phy_port
from kulcloud.core.v1.mul_nbapi import nbapi_port_list_t
from kulcloud.core.v1.mul_nbapi import flow as mul_flow

import kulcloud.core.v1.mul_nbapi as mul_nbapi
import json
import uuid
import pdb
import MySQLdb as mdb


class mlapi_json_serialization():
    def __init__(self):
        pass
    
    def nbapi_switch_brief_list_t_serialization(self, resp):
        return [{'peer':s.conn_str,'state':s.state, 'ports':s.n_ports,'dpid':'0x%lx' % s.switch_id.datapath_id} 
                    for s in resp]
    
    def nbapi_path_elem_t_serialization(self, resp, alias_map):
        return {'dpid': alias_map[resp.switch_alias],'ingress_port':resp.ingress_port_no, 'egress_port':resp.egress_port_no} 
            
    
    def nbapi_port_list_t_serialization(self, resp):
        return [self.ofp_phy_port_serialization(port) for port in resp]
       
    
    def nbapi_port_list_t_of_switch_serialization(self, ports_len, resp):
    	s_ports = mul_nbapi.ofp_phy_port_array.frompointer(resp)
        return [self.ofp_phy_port_serialization(s_ports[i]) for i in range(ports_len)]
    
    def nbapi_path_elem_list_t_serialization(self, resp, alias_map):
        return [self.nbapi_path_elem_t_serialization(path_elem, alias_map) for path_elem in resp]
    
    def nbapi_port_neigh_list_t_serialization(self, resp, alias_map):
        port_neigh_list = []
        for neigh in resp:
            if neigh.neigh_present == 1:
                port_neigh_list.append(self.c_ofp_port_neigh_serialization(neigh, alias_map))
        
        return port_neigh_list
    
    
    def nbapi_switch_flow_list_t_serialization(self, resp):
        switch_flow_list = []
        for flow in resp:
            switch_flow_list.append(self.c_ofp_flow_info_serialization(flow))
        
        return switch_flow_list
    
    def nbapi_fabric_host_list_t_serialization(self, resp):
        fab_host_list = []
        for host in resp:
            fab_host_list.append(self.c_ofp_host_mod_serialization(host))
        
        return fab_host_list
    
    def c_ofp_flow_info_serialization(self, resp):
        wildcard = mul_nbapi.OFPFW_ALL & ~(mul_nbapi.OFPFW_NW_SRC_MASK) & ~(mul_nbapi.OFPFW_DL_TYPE)
        flow_id = self.flow_tbl.match(resp.datapath_id, resp.flow, wildcard, resp.oport, 0)
        return {'flow_id':flow_id, 'flow_info':{'dpid':'0x%lx' % resp.datapath_id, 
                'nw_src': mul_nbapi.nbapi_parse_nw_addr_to_str(resp.flow.nw_src),
                'nw_dst': mul_nbapi.nbapi_parse_nw_addr_to_str(resp.flow.nw_dst),
                'dl_src': mul_nbapi.nbapi_parse_mac_to_str(resp.flow.dl_src),
                'dl_dst': mul_nbapi.nbapi_parse_mac_to_str(resp.flow.dl_dst),
                'vlan': resp.flow.dl_vlan,
                'in_port': resp.flow.in_port,
                'out_port': resp.oport,
                'bps': mul_nbapi.nbapi_parse_bps_to_str(resp.bps),
                'pps': mul_nbapi.nbapi_parse_bps_to_str(resp.pps),
                'pkt_count': resp.packet_count,
                'byte_count': resp.byte_count}
                }
        
    def c_ofp_host_mod_serialization(self, resp):
        return {'dpid': resp.switch_id.datapath_id,
                'nw_src': mul_nbapi.nbapi_parse_nw_addr_to_str(resp.host_flow.nw_src),
                'dl_src': mul_nbapi.nbapi_parse_mac_to_str(resp.host_flow.dl_src),
                'in_port': resp.host_flow.in_port
                }

    def c_ofp_port_neigh_serialization(self, resp, alias_map):
        return {'port_no':resp.port_no, 'neighbor_dpid': alias_map[resp.neigh_dpid],
                'neighbor_port_no' : resp.neigh_port }
        
    def ofp_phy_port_serialization(self, resp):
        return {'port_no':resp.port_no, 'hw_addr':mul_nbapi.nbapi_parse_mac_to_str(resp.hw_addr), 
                 'name':resp.name, 'config':resp.config, 'state':resp.state, 
                 'curr':resp.curr, 'advertised':resp.advertised,
                 'supported':resp.supported, 'peer':resp.peer} 
        
    
    def ofp_switch_fetures_serialization(self, resp):
        return {'dpid':'0x%lx' % resp.datapath_id,'n_buffers':resp.n_buffers, 'n_tables':resp.n_tables,
                            'capabilites':resp.capabilities, 'actions':resp.actions , 
                            'port_list':self.nbapi_port_list_t_of_switch_serialization((resp.header.length-32)/48, resp.ports)}
    
    
    
    def nbapi_flow_brief_list_t_serialization(self, resp):
        pass
    
        
class mlapi_json_deserialization():
    def __init__(self):
        pass 
    
    def action_deserialization(self, obj):
        act = None
        obj['action']=str(obj['action'])
        if 'OUTPUT' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_output(int(obj['value']))
        elif 'SET_VLAN_VID' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_set_vid(int(obj['value']))
        elif 'SET_VLAN_PCP' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_set_vlan_pcp(int(obj['value']))
        elif 'STRIP_VLAN' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_strip_vlan(int(obj['value']))
        elif 'SET_DL_SRC' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_set_smac(str(obj['value']))
        elif 'SET_DL_DST' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_set_dmac(str(['value']))
        elif 'SET_NW_SRC' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_set_nw_saddr(str(obj['value']))
        elif 'SET_NW_DST' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_set_nw_daddr(str(obj['value']))
        elif 'SET_NW_TOS' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_set_nw_tos(int(obj['value']))
        elif 'SET_TP_SRC' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_set_tp_sport(int(obj['value']))
        elif 'SET_TP_DST' in obj['action'] :
            act = mul_nbapi.nbapi_make_action_set_tp_dport(int(obj['value']))
        return act
        
    
    def flow_deserialization(self, obj):
        flow = mul_nbapi.nbapi_flow_make_flow(str(obj['nw_src']), str(obj['nw_dst']),
                                            int(obj['in_port']), int(obj['dl_vlan']),
                                            int(obj['dl_type']), int(obj['tp_src']),
                                            int(obj['tp_dst']), str(obj['dl_src']),
                                            str(obj['dl_dst']), int(obj['dl_vlan_pcp']),
                                            int(obj['nw_tos']), int(obj['nw_proto']))
               
        return flow   
    
    def fabric_deserialization(self, obj):
        flow = mul_nbapi.nbapi_fabric_make_flow(str(obj['nw_src']), str(obj['dl_src']), obj['in_port'])               
        return flow   
  
    def actions_deserialization(self, obj):
        actions = []
        for action in obj:
            act = self.action_deserialization(action)
            actions.append(act)
        return actions
    
    def object_decoder(self, obj):
        if obj['type'] == 'flow':            
            return self.flow_deserialization(obj)
        if obj['type'] == 'actions':            
            return self.actions_deserialization(obj['actions'])
        if obj['type'] == 'fabric':            
            return self.fabric_deserialization(obj)
        #if '__type__' in obj and obj['__type__'] == 'actions':            
        #    return self.action_deserialization(obj)
        return obj

    
    
    
class mlapi(mlapi_base_v1.MlapiBaseV1):	
    def __init__(self):
        self.json_serializer = mlapi_json_serialization()
        self.json_deserializer = mlapi_json_deserialization()   
        self.flow_tbl={}   
        self.fab_host_tbl={}
        self.alias_map = {}
	resp =[]
        # TODO : Threading to check the switch pull status and alias_map
	try:
	    resp = mul_nbapi.get_switch_all()    	
	except:
	    print 'error'
        for s in resp:
            sw_info = mul_nbapi.get_switch(s.switch_id.datapath_id)
            self.alias_map[mul_nbapi.get_switch_alias_from_switch_info(sw_info)]='0x%lx' % s.switch_id.datapath_id
            
    
    def str_uuid(self):
	return str(uuid.uuid4())
    
    
    def get_all_flow(self, conf, dpid):
	pass
	#resp = mul_nbapi.get_flows(dpid)
	#return self.json_serializer.nbapi_flow_brief_list_t_serialization(resp)
	
    def get_flow(self, conf, dpid, flow_id):
	pass
	
    def create_flow(self, conf, dpid, params):
        dpid = int(dpid, 0)
        flow_id = '' 
        params['type'] = 'flow'
        flow = self.json_deserializer.object_decoder(params)
        params['type'] = 'actions'
        action_list = self.json_deserializer.object_decoder(params)        
        #wildcards = mul_nbapi.OFPFW_ALL & ~(mul_nbapi.OFPFW_NW_SRC_MASK) & ~(mul_nbapi.OFPFW_DL_TYPE) & ~(mul_nbapi.OFPFW_NW_DST_MASK)
        wildcards = mul_nbapi.OFPFW_ALL & ~(mul_nbapi.OFPFW_NW_SRC_MASK) & ~(mul_nbapi.OFPFW_DL_TYPE)
        prio = 0
        resp = mul_nbapi.add_static_flow(dpid,flow, wildcards, prio, action_list)
        
        # flow id hash table
        # flow_id -> flow, wildcards, dpid, prioiry
        
        if resp == 0 :
            flow_id = self.str_uuid()
            self.flow_tbl[flow_id] = [dpid, flow, wildcards, action_list[-1][0].port, prio]
        else :
	    pass
	return {'flow_id' : flow_id}
	
    def update_flow(self, conf, dpid, flow_id, params):
	pass

    def delete_flow(self, conf, dpid, flow_id):
	flow_arr = self.flow_tbl[flow_id]        
        resp = mul_nbapi.delete_static_flow(flow_arr[0], flow_arr[1], flow_arr[2], flow_arr[3], flow_arr[4])
        if resp == 0 :
            resp = flow_id
        return resp
	
    def get_all_switch(self, conf):
        resp = []
        try:
            resp = mul_nbapi.get_switch_all()
        except:
            return None
        return self.json_serializer.nbapi_switch_brief_list_t_serialization(resp)
    
    def get_switch(self, conf, dpid):
        resp = None
        try:
            resp = mul_nbapi.get_switch(int(dpid, 0))
        except:
            return None
	return self.json_serializer.ofp_switch_fetures_serialization(resp)
	
	
    def get_all_port(self, conf, dpid):
        resp = None
        try:
            resp = mul_nbapi.get_switch_port_all(int(dpid, 0))
        except:
            return None
	return self.json_serializer.nbapi_port_list_t_serialization(resp)
		
	
    def get_port(self, conf, dpid, port_id):
        resp = None
        try:
            resp = mul_nbapi.get_switch_port(int(dpid, 0), int(port_id))
        except:
            return None
	return self.json_serializer.ofp_phy_port_serialization(resp)
		
	
    def get_all_link(self, dpid):
	pass
	
    def get_link(self, conf, dpid):
        resp = None
        try:
            resp = mul_nbapi.get_switch_neighbor_all(int(dpid, 0))
        except:
            return None
        return {'ports':self.json_serializer.nbapi_port_neigh_list_t_serialization(resp, self.alias_map)}
    	
    def get_all_path(self, conf):
	pass
	
    def get_path(self, path_id):
	pass
	
    def get_all_host(self, conf, tenant_id, network_id):
        fab_host_list = None
        try:
            fab_host_list = mul_nbapi.get_fabric_host_all(1)
        except:
            return None
        return self.json_serializer.nbapi_fabric_host_list_t_serialization(fab_host_list)        
    
        

    def create_host(self, conf, tenant_id, network_id, params):
        resp = None
        host_id = None
        params['type'] = 'flow'
        flow = self.json_deserializer.object_decoder(params)
        resp = mul_nbapi.add_fabric_host(int(params['dpid'],0), int(tenant_id) , int(network_id),
                                         flow, params['is_gw'])
        
        if resp > 0 :
            host_id = self.str_uuid()
            self.fab_host_tbl[host_id] = [int(params['dpid'],0), int(tenant_id), int(network_id), flow]
        else :
            return resp
        return {'host_id':host_id}
	
	
    def delete_host(self, conf, tenant_id, network_id, host_id):
        resp = None
        host_arr = self.fab_host_tbl[host_id]        
        resp = mul_nbapi.delete_fabric_host(host_arr[0], host_arr[1], host_arr[2], host_arr[3])
        if resp > 0 :
            resp = host_id
        return resp
	
	
    def get_host(self, conf, tenant_id, network_id, host_id):
	pass
	
    def update_host(self, conf, tenant_id, network_id, host_id, body):
	pass
	
    def get_all_stat(self, conf, dpid):
        flow_list = None
        try:
            flow_list = mul_nbapi.get_switch_statistics_all(int(dpid, 0))
        except:
            return None
        return {'flows':self.json_serializer.nbapi_switch_flow_list_t_serialization(flow_list)}   
    
    def stat_port_parse(self, flow_list, port_no):
        ingress={}
        egress={}
        ingress['type']='ingress'
        ingress['pkt_count']=int(0)
        ingress['byte_count']=int(0)
        ingress['avg_bps']=0.0
        ingress['avg_pps']=0.0
        ingress['flow_count']=int(0)
        
        egress['type']='egress'
        egress['pkt_count']=int(0)
        egress['byte_count']=int(0)
        egress['avg_bps']=0.0
        egress['avg_pps']=0.0
        egress['flow_count']=int(0)
        
        
        for flow in flow_list:
            if flow.flow.in_port == port_no:
                ingress['pkt_count']=ingress['pkt_count']+flow.packet_count
                ingress['byte_count']=ingress['byte_count']+flow.byte_count
                ingress['avg_bps']=ingress['avg_bps']+flow.bps
                ingress['avg_pps']=ingress['avg_pps']+flow.pps
                ingress['flow_count']=ingress['flow_count']+1
                
            if flow.oport == port_no:
                egress['pkt_count']=egress['pkt_count']+flow.packet_count
                egress['byte_count']=egress['byte_count']+flow.byte_count
                egress['avg_bps']=egress['avg_bps']+flow.bps
                egress['avg_pps']=egress['avg_pps']+flow.pps
                egress['flow_count']=egress['flow_count']+1
        
        ingress['avg_pps']=ingress['avg_pps']/ingress['flow_count']
        egress['avg_pps']=egress['avg_pps']/egress['flow_count'] 
        
        
        return {'ingress':ingress, 'egress':egress}       
        
    
    def get_stat_port(self, conf, dpid, port_no):
        flow_list = None
        try:
            flow_list = mul_nbapi.get_switch_statistics_all(int(dpid, 0))
        except:
            return None
        
        stat_port = self.stat_port_parse(flow_list, port_no)        
        return stat_port     
    
    
    def get_stat(self, conf, dpid, flow_id):
	pass 

    def path_show_route_path(self, conf, version, src_dpid, src_port, dst_dpid, dst_port):
        src_sw = None
        dst_sw = None
        src_alias = None
        dst_alias = None
        path = None
        try:
            src_sw = mul_nbapi.get_switch(int(src_dpid, 0))
            dst_sw = mul_nbapi.get_switch(int(dst_dpid, 0))
            src_alias = mul_nbapi.get_switch_alias_from_switch_info(src_sw)
            dst_alias = mul_nbapi.get_switch_alias_from_switch_info(dst_sw)
            path = mul_nbapi.get_simple_path(src_alias,int(src_port, 0),dst_alias,int(dst_port, 0))
        except:
            return None
        
        return {'hops':self.json_serializer.nbapi_path_elem_list_t_serialization(path,self.alias_map)}
    
    """ ServiceChain API """
   
    def get_all_servicech(self, conf):
        """ TODO: Extract the allocated service chain informations from DB """        
        pass
    
    def checkAndDeleteServiceChainLog(self, chain_id):
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] failed connecting to DB"
            pass

        cur.execute("DELETE FROM servicechainlog WHERE chain_id = %s", chain_id)
        con.commit()
        con.close()
    
    def insertServiceChainLog(self, chain_id, nfv_name, nfv_order):
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] failed connecting to DB"
            pass

        cur.execute("INSERT INTO servicechainlog VALUES ('%s', '%s' , '%s')" % (chain_id, nfv_name, nfv_order))
        con.commit()
        con.close()

    def insertORUpdateServiceChainLog(self, chain_id, nfv_name, nfv_order):
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] failed connecting to DB"
            pass

        cur.execute("SELECT * FROM servicechainlog WHERE chain_id = %s", chain_id)
        row = cur.fetchone()
        
        if not row:
            cur.execute("INSERT INTO servicechainlog VALUES ('%s', '%s' , '%s')" % (chain_id, nfv_name, nfv_order))
            con.commit()
        else:
            print "[WARNING] update servicechainlog"
            cur.execute("UPDATE servicechainlog SET nfv_name = %s, nfv_order = %s WHERE chain_id = %s", (nfv_name, nfv_order, chain_id))
            con.commit()

        con.close()

    def init_ippool_address(self, userid):
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] During Connecting DB"
            pass

        cur.execute("UPDATE ippool SET user_id = 0 WHERE user_id = %s", userid)
        con.commit()
        con.close()

    def controller_call_for_flowadd(self, dpid, sip, dip, in_port, out_port, prior, allocIP):
        """ Work from Chan"""
        dpid = int(dpid, 0)
        flow = mul_nbapi.nbapi_flow_make_flow(str(sip), str(dip), int(in_port), int(0), int(0), int(0), int(0), str(None), str(None), int(0), int(0), int(0))
        action_list = []
        if not allocIP:
            action_list.append(mul_nbapi.nbapi_make_action_set_nw_saddr(str(allocIP)))
        action_list.append(mul_nbapi.nbapi_make_action_output(int(out_port)))
        wildcards = mul_nbapi.OFPFW_ALL & ~(mul_nbapi.OFPFW_NW_SRC_MASK) & ~(mul_nbapi.OFPFW_DL_TYPE) & ~(mul_nbapi.OFPFW_NW_DST_MASK)
        prio = prior
        pdb.set_trace()
        resp = mul_nbapi.add_static_flow(dpid, flow, wildcards, prio, action_list)
               
        if resp == 0:
            return
        else:
            print "[ERROR] error occurrence during Flow Add"
            return
  
    def create_servicech(self, conf, params):
        """ TODO: Add chain default user registration logic """
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] During Connecting DB"
            pass

        """
        params parsing
        """
        user_ip = params["ip"]
        user_phone_num = params["phone_num"]
        user_service_level = params["service_level"]

        #define result form
        result = {"ip":user_ip, "phone_num":user_phone_num, "service_level":user_service_level, "services":[], "message":""}

        #get user id
        cur.execute("SELECT userid FROM user WHERE userip = %s AND phone_num = %s", (user_ip, user_phone_num))
        row = cur.fetchone()
        if not row:
            print "[ERROR] check the input value"
            result["message"] = "FAIL"
            return result
        user_id = row["userid"]      

        """
        Service IP Pool Registration
        """
        cur.execute("SELECT service_id, service_type FROM sa")
        rows = cur.fetchall()
        for row in rows:
            result["services"].append({"service_type":row["service_type"], "service_chain_id":0})
            cur.execute("SELECT * FROM ippool WHERE service_id = %s AND user_id = %s", (row["service_id"], user_id))
            row1 = cur.fetchone()
            if not row1:
                cur.execute("SELECT * FROM ippool WHERE service_id = %s AND user_id = 0 ORDER BY chain_id LIMIT 1", row["service_id"])
                row2 = cur.fetchone()
                if not row2:
                    print "[ERROR] not enough for assigning Service IP Address"
                    result["message"] = "FAIL"
                    return result
                
                service_chain_id = row2["chain_id"]
                service_ip = row2["ip"]
                cur.execute("UPDATE ippool SET user_id = %s WHERE chain_id = %s", (user_id, service_chain_id))
                con.commit()

                #update result form
                for service in result["services"]:
                    if service["service_type"] == row["service_type"]:
                        service["service_chain_id"] = service_chain_id

            else:
                print "[ERROR] user already have Service IP"
                result["message"] = "FAIL"
                return result
        
        """
        finding route
        """
        #DEBUG. Service Chaining log Table Truncate
        #cur.execute("TRUNCATE TABLE servicechainlog")
        #con.commit()
        #END DEBUG

        DEST_NFV = "NAT"
        MAXIMUM_HOP = 100

        cur.execute("SELECT * FROM sa")
        rows = cur.fetchall()

        for row in rows:
            #print "Service%s to %s" % (row["service_id"], dest_nfv)
            st_dpid = row["dpid"]
            st_inport = row["in_port"]
            st_outport = row["out_port"]
            uniqueip = service_ip
            chain_id = service_chain_id

            """
            finding dest. nfv
            """
            cur.execute("SELECT * FROM nfv as a, nfvvm as b WHERE a.nfv_id = b.nfv_id AND a.nfv = '%s' ORDER BY rand() limit 1" % DEST_NFV)
            row = cur.fetchone()
            if not row:
                print "[ERROR] cannot find NFV: %s" % DEST_NFV
                result["message"] = "FAIL"
                return result
            nfv_name = row["nfv_name"]
            dest_dpid = row["dpid"]
            dest_inport = row["in_port"]
            dest_outport = row["out_port"]

            #dpid, in,out port find
            stopper = 0
            s_dpid = st_dpid
            s_s_inport = 0
            s_s_outport = st_inport
            s_d_inport = st_outport
            s_d_outport = 0

            self.insertORUpdateServiceChainLog(chain_id, nfv_name, 0)

            while True:
                if s_dpid == dest_dpid:
                    break
                elif stopper > MAXIMUM_HOP:
                    break

                stopper += 1
                cur.execute("SELECT * FROM topo WHERE dpid = '%s' AND dst_dpid = '%s'" % (s_dpid, dest_dpid))
                rows = cur.fetchone()
                if rows == None:
                    print "[ERROR] error finding topology"
                    result["message"] = "FAIL"
                    return result

                if s_dpid == st_dpid:
                    s_s_inport = st_outport
                    s_s_outport = rows["in_port"]
                    s_d_inport = rows["out_port"]
                    s_d_outport = st_inport
                else:
                    s_s_inport = s_s_outport
                    s_s_outport = rows["in_port"]
                    s_d_outport = s_d_inport
                    s_d_inport = rows["out_port"]
                
                #todo: nw_src apply
                #print "sip:%s, dip:%s, dpid:%s, in_port:%s, out_port:%s" % (uniqueip, 0, s_dpid, s_s_inport, s_s_outport)
                #print "sip:%s, dip:%s, dpid:%s, in_port:%s, out_port:%s" % (0, uniqueip, s_dpid, s_d_inport, s_d_outport)
                self.controller_call_for_flowadd(s_dpid, uniqueip, None, s_s_inport, s_s_outport, 0, None)
                self.controller_call_for_flowadd(s_dpid, None, uniqueip, s_s_inport, s_s_outport, 0, None)
                s_dpid = rows["nexthop_dpid"]

            if s_dpid == dest_dpid:
                s_s_inport = s_s_outport
                s_s_outport = dest_inport
                s_d_outport = s_d_inport
                s_d_inport = dest_outport

                #print "sip:%s, dip:%s, dpid:%s, in_port:%s, out_port:%s" % (uniqueip, 0, s_dpid, s_s_inport, s_s_outport)
                #print "sip:%s, dip:%s, dpid:%s, in_port:%s, out_port:%s" % (0, uniqueip, s_dpid, s_d_inport, s_d_outport)
                self.controller_call_for_flowadd(s_dpid, uniqueip, None, s_s_inport, s_s_outport, 0, None)
                self.controller_call_for_flowadd(s_dpid, None, uniqueip, s_d_inport, s_d_outport, 0, None)

        result["message"] = "SUCCESS"
        return result
    
    def delete_servicech(self, conf, phone_num):
        pass
    
    def get_servicech(self, conf, phone_num):
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] During Connecting DB"
            pass

        """
        params parsing
        """
        user_phone_num = phone_num
        #define result form
        result = {"ip":"", "phone_num":user_phone_num, "service_level":"", "services":[], "message":""}

        cur.execute("SELECT * FROM user WHERE phone_num = %s", user_phone_num)
        row = cur.fetchone()

        if not row:
            print "[ERROR] can not find user"
            result["message"] = "FAIL"
            return result
        
        result["ip"] = row["userip"]
        result["service_level"] = row["service_level"]
        user_id = row["userid"]
        
        cur.execute("SELECT * FROM servicechainlog as a, ippool as b, sa as c WHERE a.chain_id = b.chain_id AND b.service_id = c.service_id AND b.user_id = %s ORDER BY a.nfv_order", user_id)
        rows = cur.fetchall()
      
        for row in rows:
            result["services"].append({"service_type":row["service_type"], "service_chain_id":row["chain_id"]})

        print result

        result["message"] = "SUCCESS"
        return result

    def update_servicech(self, conf, phone_num, body):
        pass  
    
    def show_service_chain_list(self, conf, service_chain_id):
        """ TODO: Extract the allocated service chain List from DB """        
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] During Connecting DB"
            pass

        cur.execute("SELECT * FROM servicechainlog as a, nfvvm as b WHERE a.chain_id = %s AND a.nfv_name = b.nfv_name", service_chain_id)
        rows = cur.fetchall()
        
        result = dict()
        result["nfv_list"] = []

        for row in rows:
            print row
            result["nfv_list"].append({"name":row["nfv_name"],"DPID":row["dpid"],"IN_PORT":row["in_port"],"OUT_PORT":row["out_port"]})
            
        return result   
    
    """ Service API """
    def get_all_service(self, conf, phone_num):
        """ TODO: Extract the allocated service chain informations from DB """        
        pass
    
    def create_service(self, conf, phone_num, service_type, params):
        """ TODO: Add chain default user registration logic """
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] During Connecting DB"
            pass
        
        """
        params parsing
        """
        user_phone_num = phone_num
        user_service_type = service_type

        #define result form
        result = {"ip":"", "phone_num":user_phone_num, "service_level":"", "services":{}, "message":""}

        cur.execute("SELECT * FROM user WHERE phone_num = %s", user_phone_num)
        row = cur.fetchone()

        if not row:
            print "[ERROR] can not find user"
            result["message"] = "FAIL"
            return result
        
        result["ip"] = row["userip"]
        result["service_level"] = row["service_level"]
        user_id = row["userid"]
        lnfv = params["nfv_list"]

        """
        NFV Service level check
        """
        user_service_level = row["service_level"]

        for nfv in lnfv:
            cur.execute("SELECT service_level FROM nfv WHERE nfv = %s", nfv)
            row = cur.fetchone()
            
            if row["service_level"] > user_service_level:
                print "[ERROR] this user not satisfied the NFV service level"
                result["message"] = "FAIL"
                return result
        
        """
        Service IP Pool Registration
        """
        cur.execute("SELECT service_id, service_type FROM sa WHERE service_type = %s", user_service_type)
        row = cur.fetchone()
        if not row:
            print "[ERROR] can not find service_type"
            result["message"] = "FAIL"
            return result

        result["services"] = {"service_type":row["service_type"], "service_chain_id":0, "nfv_list":[]}
        service_id = row["service_id"]

        cur.execute("SELECT * FROM ippool WHERE service_id = %s AND user_id = %s", (service_id, user_id))
        row1 = cur.fetchone()
        if not row1:
            cur.execute("SELECT * FROM ippool WHERE service_id = %s AND user_id = 0 ORDER BY chain_id LIMIT 1", row["service_id"])
            row2 = cur.fetchone()
            if not row2:
                print "[ERROR] not enough for assigning Service IP Address"
                result["message"] = "FAIL"
                return result
                
            service_chain_id = row2["chain_id"]
            service_ip = row2["ip"]
            cur.execute("UPDATE ippool SET user_id = %s WHERE chain_id = %s", (user_id, service_chain_id))
            con.commit()

        else:
            service_chain_id = row1["chain_id"]
            service_ip = row1["ip"]

        #update result form
        result["services"]["service_chain_id"] = service_chain_id
        
        """
        #TODO: for multiple Services input
        lnfv = []
        #init listNFV
        for i in range(length):
            lnfv.append([])
        ServiceNumber = 0

        #input listNFV
        for i in range(2, length):
            if (sys.argv[i].isdigit()):
                ServiceNumber = int(sys.argv[i])
            else:
                lnfv[ServiceNumber].append(sys.argv[i])
        """

        MAXIMUM_HOP = 100

        """
        service loop
        """
        cur.execute("SELECT * FROM sa WHERE service_id = '%d'" % service_id)
        row = cur.fetchone()

        if not row:
            print "[ERROR] can not find service_type"
            result["message"] = "FAIL"
            return result

        start_dpid = row["dpid"]
        start_inport = row["in_port"]
        start_outport = row["out_port"]
        serviceIP = service_ip
        chain_id = service_chain_id

        #result value
        s_s_inport = 0
        s_s_outport = start_inport
        s_d_inport = start_outport
        s_d_outport = 0
        s_dpid = start_dpid

        stopper = 0 

        self.checkAndDeleteServiceChainLog(chain_id)

#DEBUG start
        #self.controller_call_for_flowadd(s_dpid, serviceIP, None, s_s_inport, s_s_outport, 1, serviceIP)
        #self.controller_call_for_flowadd(s_dpid, None, serviceIP, s_s_inport, s_s_outport, 1, row["ip"])
#debug end

        for i in range(len(lnfv)):
            if not lnfv[i]:
                break
            else:
                cur.execute("SELECT * FROM nfv as a, nfvvm as b WHERE a.nfv_id = b.nfv_id AND a.nfv = '%s' ORDER BY rand() limit 1" % lnfv[i])
                row = cur.fetchone()
                if not row:
                    print "[ERROR] cannot find NFV: %s" % lnfv[i]
                    result["message"] = "FAIL"
                    return result

                nfv_name = row["nfv_name"]
                endnfv_dpid = row["dpid"]
                endnfv_inport = row["in_port"]
                endnfv_outport = row["out_port"]
                firstloopOfnfv = True 

                self.insertServiceChainLog(chain_id, nfv_name, i)

                while True:
                    if s_dpid == endnfv_dpid:
                        if (s_dpid == start_dpid) and (stopper < 1):
                            s_s_inport = start_outport
                            s_s_outport = row["in_port"]
                            s_d_inport = row["out_port"]
                            s_d_outport = start_inport
                            stopper += 1
                        elif firstloopOfnfv:
                            s_s_inport = s_d_inport
                            s_d_outport = s_s_outport
                            s_s_outport = row["in_port"]
                            s_d_inport = row["out_port"]
                            firstloopOfnfv = False
                        else:
                            s_s_inport = s_s_outport
                            s_s_outport = endnfv_inport
                            s_d_outport = s_d_inport
                            s_d_inport = endnfv_outport

                        print "sip:%s, dip:%s, dpid:%s, in_port:%s, out_port:%s" % (serviceIP, 0, s_dpid, s_s_inport, s_s_outport)
                        print "sip:%s, dip:%s, dpid:%s, in_port:%s, out_port:%s" % (0, serviceIP, s_dpid, s_d_inport, s_d_outport)
                        self.controller_call_for_flowadd(s_dpid, serviceIP, None, s_s_inport, s_s_outport, 1, None)
                        self.controller_call_for_flowadd(s_dpid, None, serviceIP, s_s_inport, s_s_outport, 1, None)
                        result["services"]["nfv_list"].append(nfv_name)
                        break

                    elif stopper > MAXIMUM_HOP:
                        break


                    cur.execute("SELECT * FROM topo WHERE dpid = '%s' AND dst_dpid = '%s'" % (s_dpid, endnfv_dpid))
                    row = cur.fetchone()
                    if row == None:
                        print "[ERROR] error finding topology"
                        exit()

                    if (s_dpid == start_dpid) and (stopper < 1):
                        s_s_inport = start_outport
                        s_s_outport = row["in_port"]
                        s_d_inport = row["out_port"]
                        s_d_outport = start_inport
                    elif firstloopOfnfv:
                        s_s_inport = s_d_inport
                        s_d_outport = s_s_outport
                        s_s_outport = row["in_port"]
                        s_d_inport = row["out_port"]
                        firstloopOfnfv = False
                    else:
                        s_s_inport = s_s_outport
                        s_s_outport = row["in_port"]
                        s_d_outport = s_d_inport
                        s_d_inport = row["out_port"]

                    print "sip:%s, dip:%s, dpid:%s, in_port:%s, out_port:%s" % (serviceIP, 0, s_dpid, s_s_inport, s_s_outport)
                    print "sip:%s, dip:%s, dpid:%s, in_port:%s, out_port:%s" % (0, serviceIP, s_dpid, s_d_inport, s_d_outport)
                    self.controller_call_for_flowadd(s_dpid, serviceIP, None, s_s_inport, s_s_outport, 1, None)
                    self.controller_call_for_flowadd(s_dpid, None, serviceIP, s_s_inport, s_s_outport, 1, None)

                    s_dpid = row["nexthop_dpid"]
                    stopper += 1
                    firstloopOfnfv = False

        result["message"] = "SUCCESS"
        return result
    
    def delete_service(self, conf, phone_num, service_type):
        """ TODO: Delete chain of service_type """
        return {"result":"SUCCESS"}
    
    def get_service(self, conf, phone_num, service_type):
        pass
    
    def update_service(self, conf, phone_num, service_type, body):
        pass  
    
    """ SADB API """
    def get_all_sadb(self, conf):
        """ TODO: Extract the allocated service chain informations from DB """        
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] During Connecting DB"
            pass

        cur.execute("SELECT * FROM sa")
        rows = cur.fetchall()
        
        result = dict()
        result["services"] = []

        for row in rows:
            result["services"].append({"service_type":row["service_type"],"DPID":row["dpid"],"IP":row["ip"],"IN_PORT":row["in_port"],"OUT_PORT":row["out_port"]})
            
        return result   
    
    """ NFVDB API """
    def get_all_nfvdb(self, conf):
        """ TODO: Extract the NFVDB list from DB """        
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] During Connecting DB"
            pass

        cur.execute("SELECT * FROM nfv as a, nfvvm as b, (SELECT * FROM (SELECT * FROM nfvvmStatus ORDER BY time DESC) as aa GROUP BY nfv_vm_id) as c WHERE a.nfv_id = b.nfv_id AND b.nfv_vm_id = c.nfv_vm_id")
        rows = cur.fetchall()
        
        result = dict()
        result["nfv_list"] = []

        for row in rows:
            result["nfv_list"].append({"type":row["type"],"name":row["nfv_name"],"DPID":row["dpid"],"IN_PORT":row["in_port"],"IN_PORT_PPS":row["in_port_pps"],"OUT_PORT":row["out_port"],"OUT_PORT_PPS":row["out_port_pps"],"CPU_USAGE":row["cpu_usage"]})
            
        return result   
    
    def create_nfvdb(self, conf, params):
        """ TODO: Add NFV Node to the DB """
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] During Connecting DB"
            pass

        cur.execute("SELECT nfv_id FROM nfv ORDER BY nfv_id DESC LIMIT 1")
        row = cur.fetchone()

        nfv_id = row["nfv_id"] + 1
        nfv_type = params["type"]
        nfv_name = params["name"]
        
        cur.execute("SELECT nfv_id FROM nfv WHERE nfv = %s", nfv_name)
        row = cur.fetchone()

        if not row:
            #go on
            try:
                cur.execute("INSERT INTO nfv VALUE (%s, %s, %s)",(nfv_id, nfv_name, nfv_type))
                con.commit()
            except:
                con.rollback()
            return{"result": "SUCCESS"}
        else:
            print "[ERROR] duplicated NFV name"
            return {"result": "FAIL"}
           
    def delete_nfvdb(self, conf, name):
        """ TODO: Delete NFV Node from the DB """
        return {"result":"SUCCESS"}
    
    def update_nfvdb(self, conf, name, body):
        """ TODO: Update NFV Node from the DB """
        pass  

    def create_nfvvmdb(self, conf, params):
        """ TODO: Add NFV Node to the DB """
        """ Work from Chan"""
        try:
            con = mdb.connect('localhost', 'root', 'z2028757', 'skdemo')
            cur = con.cursor(mdb.cursors.DictCursor)
        except:
            print "[ERROR] During Connecting DB"
            pass

        cur.execute("SELECT nfv_id FROM nfv WHERE nfv = %s LIMIT 1", params['name'])
        row = cur.fetchone()

        if not row:
            print "[ERROR] N/A nfv name"
            return {"result": "FAIL"}
        else:
            nfv_id = row["nfv_id"]
            nfv_name = params["nfv_name"]
            nfv_dpid = params["dpid"]
            nfv_inport = params["in_port"]
            nfv_outport = params["out_port"]

            cur.execute("SELECT nfv_name FROM nfvvm WHERE nfv_name = %s LIMIT 1", nfv_name)
            row = cur.fetchone()
            
            if not row:
                #go on
                cur.execute("SELECT nfv_vm_id FROM nfvvm ORDER BY nfv_vm_id DESC LIMIT 1")
                row = cur.fetchone()
                nfv_vmid = row["nfv_vm_id"] + 1

                try:
                    cur.execute("INSERT INTO nfvvm VALUES (%s, %s, %s, %s, %s, %s)",(nfv_id, nfv_vmid, nfv_name, nfv_dpid, nfv_inport, nfv_outport))
                    con.commit()
                    cur.execute("INSERT INTO nfvvmStatus (nfv_vm_id, in_port_pps, out_port_pps, cpu_usage) VALUES (%s, 0, 0, 0)", nfv_vmid)
                    con.commit()
                    return {"result": "SUCCESS"}
                except:
                    con.rollback()
                    return {"result": "FAIL"}
            else:
                print "[ERROR] duplicated nfv_vm name"
                return {"result": "FAIL"}

